using Random
using CSV
using DataFrames
using Statistics
using StatsBase
using Distributions
using Printf
cd(@__DIR__)


"""
    ssp(origin, destination[; networkName, parameter=["TT"], paradigm="expected value", distribution=Weibull(), threshold=1, leastcount=1/1000, Œ∑=100, showPath=false])

For a given paradigm, engine modes to operate in and parameters for the cost function, ssp performs Œ∑ simulations 
for a vehicle traveling between origin-destination.

# Arguments
- `origin`::Integer                                 : Origin node
- `destination`::Integer                            : Destination node
- `networkName`::String                             : network
- `parameter`::Array{String}                        : distance (TD), time (TT), energy (FC), emissions (CH‚ÇÑ, CO, CO‚ÇÇ, N‚ÇÇO, NO‚Çì, PM, ROG, SO‚Çì)
- `paradigm`::String='expected value'               : determnistic, expected value, variance, reliability
- `threshold`::Float                                : threshold cost for reliability analysis
- `leastcount`::Float64                             : smallest value of discretized cost
- `distribution`::UnivariateDistribution            : link speed distribution function
- `Œ∑`::Integer                                      : Number of simulations
- `showPath`::Bool                                  : if true shows every path simulated

# IO Units
- distance  : miles
- energy    : litre of fuel
- emissions : kg
"""
function ssp(origin, destination; networkName, parameter=["TT"],
    paradigm="expected value", distribution=Weibull(), threshold=1,
    leastcount=1/1000, numSims=100, showPath=false)

    printstyled("\n----- $paradigm - $(join(parameter, ", "))-----\n", color=:cyan)

    # Algorithm parameters
    r, s = origin, destination
    CÃÖ, Œ¥ = threshold, leastcount
    N = Int64[]                             # Nodes
    A = Array{Int64,1}[]                    # Arcs as adjacency list
    M = Array{Int64,1}[]                    # Link class
    d = Array{Float64,1}[]                  # Link length
    Œ± = Array{Float64,1}[]                  # Link scale parameter
    Œ≤ = Array{Float64,1}[]                  # Link shape parameter
    Œº = Array{Float64,1}[]                  # Average link cost
    œÉ¬≤ = Array{Float64,1}[]                 # Var/iance in link cost
    pr = Array{Array{Float64,1},1}[]        # Link cost probabilities
    k‚Çó = Array{Int64,1}[]                    # Lower-bounds for pr ‚Üí 0
    k·µ§ = Array{Int64,1}[]                   # Upper-bounds for pr ‚Üí 0
    prune = Int64[]                         # Pruned nodes
    parameters = String[]                   # Parameters
    ‚Ñø = Float64[]                           # Cost parameters
    Œ∑ = Float64[]                           # Coefficients
    Œ≥ = Array{Int64,1}[]                    # Binary geofence indicator
    Œ∏ = Float64[]                           # Binary internal array

    function popall!(arr) while !isempty(arr) pop!(arr) end end

    # Network build
    # Fetches netowrk files and builds network related vectors
    function build()
        println("\nBuilding network...")
        # Coefficient file
        coefFile = CSV.File("Network\\$networkName\\coef.csv")
        df‚ÇÅ = DataFrame(coefFile)
        for r in 1:nrow(df‚ÇÅ)
            p = df‚ÇÅ[r,1]::String
            push!(parameters, p)
            for c in 2:4
                append!(‚Ñø, df‚ÇÅ[r,5])
                append!(Œ∑, df‚ÇÅ[r,c])
                if p in parameter append!(Œ∏, 1.0) else append!(Œ∏, 0.0) end
            end
        end

        # Network file
        networkFile = CSV.File("Network\\$networkName\\network.csv")
        df‚ÇÇ = DataFrame(networkFile)
        head = df‚ÇÇ[!,1]::Array{Int64,1}
        tail = df‚ÇÇ[!,2]::Array{Int64,1}
        linkClass = df‚ÇÇ[!,3]::Array{Int64,1}
        linkLength = df‚ÇÇ[!,4]::Array{Float64,1}
        distShape = df‚ÇÇ[!,5]::Array{Float64,1}
        distScale = df‚ÇÇ[!,6]::Array{Float64,1}
        dist = typeof(distribution)
        n = max(maximum(head), maximum(tail))
        for i in 1:n
            append!(N, i)
            push!(A, [])
            push!(M, [])
            push!(d, [])
            push!(Œ±, [])
            push!(Œ≤, [])
            push!(Œº, [])
            push!(œÉ¬≤, [])
            push!(pr, [])
            push!(k‚Çó, [])
            push!(k·µ§, [])
        end

        for i in 1:length(head)
            append!(A[head[i]], tail[i])
            append!(M[head[i]], linkClass[i])
            append!(d[head[i]], linkLength[i])
            append!(Œ±[head[i]], distShape[i])
            append!(Œ≤[head[i]], distScale[i])
        end

        # Geofence file
        append!(Œ≥, [[0 for j in A[i]] for i in N])
        if "geofence.csv" in readdir("Network\\$networkName\\")
            geofFile = "Network\\$networkName\\geofence.csv"
            csv‚ÇÉ = CSV.File(geofFile)
            df‚ÇÉ = DataFrame(csv‚ÇÉ)
            for r in 1:nrow(df‚ÇÉ)
                i = df‚ÇÉ[r,1]::Int64
                j = df‚ÇÉ[r,2]::Int64
                k = findfirst(x -> (x == j), A[i])
                Œ≥[i][k] =  df‚ÇÉ[r,3]
            end
        end

        # Generating cost metrics - mean, variance and proability distribution
        X(v) = [v^y for x in 1:length(parameters) for y in 0:2]
        L = Int(round(CÃÖ/Œ¥))
        Z‚Çò = Array{Float64,1}[[] for class in sort(unique(linkClass))]
        # Generating random instances of link cost for a 1 mile long link of each link class
        for (m, class) in enumerate(sort(unique(linkClass)))
            k = findfirst(x -> (x == class), linkClass)::Int64
            i, j = head[k], tail[k]
            k = findfirst(x -> (x == j), A[i])::Int64
            Random.seed!(i * k)
            V = rand(dist(Œ±[i][k], Œ≤[i][k]), 1500)::Array{Float64,1}
            Z = [sum(Œ∑ .* X(v) .* 1/v .* ‚Ñø .* Œ∏) for v in V]
            Z‚Çò[m] = Z
        end
        # Using the random instances to generate link cost metrics for each link
        Threads.@threads for i in N
             for (k,j) in enumerate(A[i])
                 m = M[i][k]
                 C = Z‚Çò[m] .* d[i][k] .* (1 + Œ≥[i][k]*1e6)
                 append!(Œº[i], mean(C))
                 append!(œÉ¬≤[i], var(C))
                 if paradigm == "reliability" 
                    # Generating probability distribution
                     L·∂ú = Int(round(maximum(C) / Œ¥))
                     h = fit(Histogram, C, (0.5:1:(max(L, L·∂ú) + 0.5)) * Œ¥).weights
                     if sum(h) == 0 push!(pr[i], h)
                     else push!(pr[i], h / sum(h)) end
                     maxm, argmaxm = findmax(pr[i][k])
                     # Approximating pr ‚Üí 0
                     ix‚Çó = findfirst(x -> (maxm/x  < 1000), pr[i][k][1:argmaxm])
                     ix·µ§ = findfirst(x -> (maxm/x < 1000), reverse(pr[i][k][argmaxm:L]))
                     if (isnothing(ix‚Çó)) ix‚Çó = 1 end
                     if (isnothing(ix·µ§)) ix·µ§ = 1  end
                     append!(k‚Çó[i], ix‚Çó)
                     append!(k·µ§[i], L - ix·µ§ + 1)
                end
            end
        end

        println("Built fin.")
    end

    # Djikstra's label setting algorithm
    # Returns predecessor and cost labels L,C for every node i for least cost path from/to node r given arc costs c‚Çê
    function djk(c‚Çê, r, type)
        ùê¥ = Array{Int64,1}[[] for i in N]
        ùëê‚Çê= Array{Float64,1}[[] for i in N]

        for i in N
            for (k,j) in enumerate(A[i])
                if type == "source"
                    push!(ùê¥[i], A[i][k])
                    push!(ùëê‚Çê[i], c‚Çê[i][k])
                else
                    push!(ùê¥[j], i)
                    push!(ùëê‚Çê[j], c‚Çê[i][k])
                end
            end
        end
 
        L = [if i == r r else -1 end for i in N]       # Predecessor label
        C = [if i == r 0.0 else Inf end for i in N]    # Cost label
        X = copy(N)                                    # Set of open nodes

        i = r
        deleteat!(X, i)
        while !isempty(X)
            for (k,j) in enumerate(ùê¥[i])
                c = C[i] + ùëê‚Çê[i][k]
                if c < C[j]  && j in X L[j], C[j] = i, c end
            end
            index = argmin([C[j] for j in X])
            i = X[index]
            deleteat!(X, index)
        end
        return L, C
    end

    # Djikstra's shortest path
    # Returns Djikstra's shortest path from/to node r to/from node s using label L
    function djkpath(L, r, s)
        source, sink = false, false
        if L[r] == r source = true end
        if L[s] == s sink = true end

        if sink r, s = s, r end

        p = [s]
        i = s
        while i ‚â† r
            i = Int(L[i])
            append!(p, i)
        end

        if source reverse!(p) end
        return p
    end

    # Increasing Order of Time Budget
    # Returns reliability and successor node index matrix (Policy tables)
    function f()
        L = Int(round(CÃÖ/Œ¥))
        N‚Ä≤ = filter(x -> !(x in prune), N)
        filter!(x -> (x ‚â† s), N‚Ä≤)
        œÅ = [[if i==s 1.0 else 0.0 end for _ in 0:L] for i in N]    # Reliability
        Œª = [[if i==s s else -1 end for _ in 0:L] for i in N]       # Index of next node in ùíú[i]
        for l in 1:L
            Threads.@threads for i in N‚Ä≤
                œÅ[i][l + 1], Œª[i][l + 1] = findmax([sum([pr[i][k][k‚Çí] * œÅ[j][l - k‚Çí + 1] for k‚Çí in min(l, k‚Çó[i][k]):min(l, k·µ§[i][k])]) for (k,j) in enumerate(A[i])])
            end
        end
        return œÅ, Œª
    end

    # Path reliability
    # Returns reliability of a given path (p)
    function reliability(p)
        L = Int(round(CÃÖ/Œ¥))
        œÅ = [[if i==s 1.0 else 0.0 end for _ in 0:L] for i in N]    # Reliability
        for l in 1:L
            for m in length(p):-1:2
                i, j = p[m-1], p[m]
                k = findfirst(x -> (x == j), A[i])::Int64
                œÅ[i][l+1] = sum([pr[i][k][k‚Çí] * œÅ[j][l - k‚Çí + 1] for k‚Çí in min(l, k‚Çó[i][k]):min(l,k·µ§[i][k])])
            end
        end
        return œÅ
    end

    # Monte-Carlo Simulation
    # Return simulated parameters (distances, travel time and emissions), and simulated paths
    function mcs()
        println("\nSimulating...")
        dist = typeof(distribution)
        L = Int(round(CÃÖ/Œ¥))
        X(v) = [v^y for x in 1:length(parameters) for y in 0:2]

        paths = Array{Int64,1}[[] for _ in 1:numSims]
        Z = [[0.0 for _ in 1:numSims] for _ in parameters]
        C = [0.0 for _ in 1:numSims]

        if paradigm == "deterministic"
            for n in 1:numSims
                Z‚Çó = [[[-1.0 for _ in 1:length(A[i])] for i in N] for _ in 1:length(parameters)]
                C‚Çó = [[-1.0 for _ in 1:length(A[i])] for i in N]
                for i in N
                    for (k,j) in enumerate(A[i])
                        Random.seed!(i * n)
                        v = rand(dist(Œ±[i][k], Œ≤[i][k]))
                        z = Œ∑ .* X(v) .* (d[i][k]/v)
                        for x in 1:length(parameters) Z‚Çó[x][i][k] = sum(z[(3x-2):3x]) end
                        C‚Çó[i][k] = sum(z .* ‚Ñø .* Œ∏)
                    end
                end
                L·µ£, _ = djk(C‚Çó, r, "source")
                p = djkpath(L·µ£, r, s)
                for m in 2:length(p)
                    i, j = p[m-1], p[m]
                    k = findfirst(x -> (x == j), A[i])::Int64
                    for x in 1:length(parameters) Z[x][n] += Z‚Çó[x][i][j] end
                    C[n] += C‚Çó[i][k]
                end
                paths[n] = p
            end

        elseif paradigm == "expected value"
            println("Algorithm run time")
            @time L·µ£, _ = djk(Œº, r, "source")
            @time p = djkpath(L·µ£, r, s)
            #œÅ = reliability(p)
            for n in 1:numSims
                for m in 2:length(p)
                    i, j = p[m-1],  p[m]
                    k = findfirst(x -> (x == j), A[i])::Int64
                    Random.seed!(i * n)
                    v = rand(dist(Œ±[i][k], Œ≤[i][k]))
                    z = Œ∑ .* X(v) .* (d[i][k]/v)
                    for x in 1:length(parameters) Z[x][n] += sum(z[(3x-2):3x]) end
                    C[n] += sum(z .* ‚Ñø .* Œ∏)
                end
                paths[n] = p
            end

        elseif paradigm == "variance"
            println("Algorithm run time")
            @time L·µ£, _ = djk(œÉ¬≤, r, "source")
            @time p = djkpath(L·µ£, r, s)
            #œÅ = reliability(p)
            for n in 1:numSims
                for m in 2:length(p)
                    i, j = p[m-1], p[m]
                    k = findfirst(x -> (x == j), A[i])::Int64
                    Random.seed!(i * n)
                    v = rand(dist(Œ±[i][k], Œ≤[i][k]))
                    z = Œ∑ .* X(v) .* (d[i][k]/v)
                    for x in 1:length(parameters) Z[x][n] += sum(z[(3x-2):3x]) end
                    C[n] += sum(z .* ‚Ñø .* Œ∏)
                end
                paths[n] = p
            end

        elseif paradigm == "reliability"
            println("Pre-processing...")
            # Pruning
            c‚Çò·µ¢‚Çô = [[k‚Çó[i][k] * Œ¥ for k in 1:length(A[i])] for i in N]
            _, C·µ£ = djk(c‚Çò·µ¢‚Çô, r, "source")
            _, C‚Çõ = djk(c‚Çò·µ¢‚Çô, s, "sink")
            for i in N if C·µ£[i] + C‚Çõ[i] > CÃÖ append!(prune, i) end end

            # Tie breaker
            _, C‚Çí = djk(Œº, s, "sink")
            for i in N
                z = [if (A[i][k] in prune) Inf else Œº[i][k] + C‚Çí[j] end for (k,j) in enumerate(A[i])]
                k = sortperm(z)
                A[i] = A[i][k]
                d[i] = d[i][k]
                Œ±[i] = Œ±[i][k]
                Œ≤[i] = Œ≤[i][k]
                Œº[i] = Œº[i][k]
                œÉ¬≤[i] = œÉ¬≤[i][k]
                pr[i] = pr[i][k]
                k‚Çó[i] = k‚Çó[i][k]
                k·µ§[i] = k·µ§[i][k]
            end
            println("Pre-processing fin.")

            println("Algorithm run time")
            @time L‚Çõ, _ = djk(Œº, s, "sink")
            @time œÅ, Œª = f()
            for n in 1:numSims
                i = r
                append!(paths[n], i)
                while i ‚â† s
                    if (CÃÖ - C[n] ‚â• Œ¥ && (prune ‚â† N))     # Second condtion protects against very rare case when all nodes are pruned
                        l = Int(round((CÃÖ - C[n])/Œ¥))
                        k = Œª[i][l + 1]
                        Random.seed!(i * n)
                        v = rand(dist(Œ±[i][k], Œ≤[i][k]))
                        z = Œ∑ .* X(v) .* (d[i][k]/v)
                        for x in 1:length(parameters) Z[x][n] += sum(z[(3x-2):3x]) end
                        C[n] += sum(z .* ‚Ñø .* Œ∏)
                        i = A[i][k]
                        append!(paths[n], i)
                    else
                        p = djkpath(L‚Çõ, i, s)             # Remaining route is completed as Least Expected Path
                        append!(paths[n], p[2:end])
                        for m in 2:length(p)
                            i, j = p[m-1], p[m]
                            k = findfirst(x -> (x == j), A[i])::Int64
                            Random.seed!(i * n)
                            v = rand(dist(Œ±[i][k], Œ≤[i][k]))
                            z = Œ∑ .* X(v) .* (d[i][k]/v)
                            for x in 1:length(parameters) Z[x][n] += sum(z[(3x-2):3x]) end
                            C[n] += sum(z .* ‚Ñø .* Œ∏)
                        end
                        i = s
                    end
                end
            end
        end

        parameterize = Dict{String, String}("TD" => "TD", "TT" => "TT", "FC" => "FC",
        "CH4" => "CH‚ÇÑ", "CO"  => "CO", "CO2" => "CO‚ÇÇ" , "N2O" => "N‚ÇÇO", "NOx" => "NO‚Çì", 
        "PM"  => "PM", "ROG" => "ROG", "SOx" => "SO‚Çì")
        uniquePaths = unique(paths)
        pathCount = [length(findall(x -> (x == path), paths)) for path in uniquePaths]
        df = DataFrame(stat = ["mean", "var", "median", "min", "max"])
        for i in 1:length(parameters)
            df[!,Symbol(parameterize[parameters[i]])] = [@sprintf("%.2E",mean(Z[i])), @sprintf("%.2E", var(Z[i])),
            @sprintf("%.2E", median(Z[i])), @sprintf("%.2E", minimum(Z[i])), @sprintf("%.2E", maximum(Z[i]))]
        end
        df[!,Symbol("Cost")] = [@sprintf("%.2E", mean(C)), @sprintf("%.2E", var(C)), @sprintf("%.2E", median(C)), @sprintf("%.2E", minimum(C)), @sprintf("%.2E", maximum(C))]
        println("\nTravel Statistics:")
        println(df)

        #if paradigm in ("expected value", "variance", "reliability") println("\nactual reliability: $(round(œÅ[r][L + 1], digits=5))") else println("\nactual reliability: ", "NA") end
        println("calculated reliability: $(round(length(findall(x -> (x ‚â§ CÃÖ), C))/numSims, digits=5))")
        if showPath
            println("\nPaths:")
            for path in uniquePaths println("   Path => $path") end
            println("Path count: $pathCount")
        end
        println("\nSimulation fin.")

        return Z, C, uniquePaths
    end

    printstyled("\nOrigin-Destination: $r - $s\n"; color=:red)
    @time build()
    @time mcs()
end
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
